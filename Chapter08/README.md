# 프로그래밍 언어 처리

## 어셈블리 언어

원하는 명령어 코드를 작성하려면 해당하는 비트를 직접 찾아서 작성해야했던 초기의 개발 방식을
조금 더 편리하게 만들어준 중간단계 언어. <br>
암기용 약어(mnemonic) 등을 활용해서 명령어를 대체하는 형태.

## 고수준 언어 & 구조적 프로그래밍

더 복잡한 작업을 표현하기 위해 더 적은 단어를 사용하는 필요에 의해 탄생.
더 높은 추상화 단계에서 동작한다. <br>

#### "추상화" 란?

토마토, 바나나, 수박, 오렌지 가 있다 치자. 하나하나 필요에 따라 부르는 것도 중요하지만
전체를 다룰 때, 전체를 모아서 뭉뚱그려 부르고 싶을 땐 뭐라고 부를까? <br>
"과일". <br>
"과일" 은 위 개체들을 '추상화' 한 명칭인 것이다.

"컴파일러" 라는 프로그램에 의해 기계어로 번역된다.
<br>
<br>
포트란 같이 레이블과 GOTO 구문을 자유롭게 조합할 수 있는 비구조적 언어는 코드를 변경하다 보면
금방 순서가 뒤섞이고 레이블을 찾기가 어려워진다.
이를 개선하기 위해 조금 더 추상화를 한 구조적 프로그래밍 언어 (파이썬, 자바스크립트 등)
가 등장했다.

## 어휘 분석

Lexical analysis <br>

1. 코드를 기호 기준으로 슬라이스 한다. [토큰화]
2. 버퍼를 비워 자리를 마련하고
3. 문자를 받아온다.
4. 구분자 여부를 파악한다.
   a. 맞으면 버퍼 자리를 확인한다.
   b. 아니면 토큰 버퍼 끝에 연결한다.

### 베커스 나우르 표기법 (BNF, Backus-Naur Form)

```json
<NID>         ::= <let-num> [ 1,31<let-num-hyp> ]

<let-num-hyp> ::= <upper> | <lower> | <number> | "-"

<let-num>     ::= <upper> | <lower> | <number>

<upper>       ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" |
                  "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" |
                  "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" |
                  "Y" | "Z"

<lower>       ::= "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" |
                  "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" |
                  "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" |
                  "y" | "z"

<number>      ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" |
                  "8" | "9"
```

RFC2141 중 일부. <br>
"|", "&" 와 같이 JS 에서도 쓰이는 문법이 정의된 것을 볼 수 있다.

## 정규식

언어를 지정하기 위한 언어. string 의 패턴을 매칭하는 방식을 지정한 언어.
grep (globally search a regular expression and print) 유틸리티 명령어에도 활용.
<br>
[Regular Expression - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)
<br>

## 파스 트리 [Parse Tree]

인터프리터 언어는 VM(Virtial Machine) 에서 실행되기 때문에 기계어 명령어를 생성하지 않는다.
인터프리터 언어는 말그대로 인터프리터에 의해 실행되기도 하지만 중간어로 컴파일 되기도 한다. <br>
-> JS 를 중간어로 볼 수도 있다고 한다.
<br>
<br>

기능상 언어 문법으로 만들어진 플로우 차트. <br>
계산기를 예로 들면,

1. 덧셈
   1. 정수 입력
   2. 배수 확인
      1. 앞배수가 정수인지 확인
      2. 뒷배수가 정수인지 확인
2. 뺄셈
3. ...

### 인터프리터

프론트엔드에서 어휘 분석, 문법 파싱으로 생성한 파스 트리는 환경별로 갖춰진
백엔드 머신에 의해 실행된다.

### 컴파일러

인터프리터와 마찬가지로 생성된 파스트리를 어셈블리어/기계어 로 바꿔주는 코드 생성기가 백엔드 앞단에 추가된다.

<img src="https://www.guru99.com/images/1/053018_0616_CompilervsI1.png">

-> 인터프리터 : 절차가 비교적 단순하므로 빌드가 빠르다.
-> 컴파일러 : 머신 코드가 생성되므로 실행이 빠르다.

## 최적화 [Optimizer]

- IDE 에서 제공하는 최적화

```javascript
function test() {
  const td = 5; // 최적화 return 5
  return td;
}
```

- loop invariant
  반복문 안에서 여러 번 호출되는 것은 다른 변수로 대체

- strength reduction
  곱셈 등 연산이 큰 작업을 더 작은 단위의 연산(ex-덧셈) 으로 쪼갬.
